#  iHRM人力资源 - 组织架构

[TOC]

# 一、展示数据-树形组件

**树形组件：用层级结构展示信息，可展开或者折叠**

![image-20240312202534361](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312202534361.png)

> 使用element-ui组件
>
> https://element.eleme.cn/#/zh-CN/component/tree



## 1.1 组件说明

![image-20240312205537574](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312205537574.png)

```html
<template>
  <!--为什么这里写container和app-container？ 因为我们最初的时候导入过样式-->
  <div class="container">
    <!--在此容器上加了边距（上下30px，左右140px）-->
    <div class="app-container">
      组织架构
      <!--展示树形结构-->
      <!--此处正好是标签的属性名叫props，和vue框架中组件传递数据不是一个-->
      <!--default-expand-all属性表示默认将所有的树形结构打开，完整写法是 :default-expand-all=“true” (一定带冒号)-->
      <el-tree :data="depts" :props="defaultProps" default-expand-all>

      </el-tree>
    </div>
  </div>
</template>

<script>
export default {
  name: 'Department',
  data() {
    return {
      // 数组属性
      depts: [{ name: '传智教育', children: [{ name: '总裁办' }, { name: '行政部' }, { name: '人事部' }] }],
      defaultProps: {
        // 当前层级数据（在这里找此层级的显示数据）
        label: 'name',
        // 子层级（其实就是层级结构，在这里找子节点）
        children: 'children'
      }
    }
  }
}
</script>

<style scoped>
.app-container {
  padding: 30px 140px;
}
</style>

```

**效果图**

![image-20240312205856054](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312205856054.png)

## 1.2 树组件自定义结构获取作用域数据

### 1.2.1 说明

我们其实要实现下面的这种树形结构，在右侧还有操作地方，但是我们在1.1中只展示了名称没有显示右侧

因为element-ui中树形结构默认只显示节点的名称，如果我们想树形结构左边有内容右边也有内容的话，就需要对树形结构进行自定义

我们这个地方需要再使用一个element-ui的行和列组件

![image-20240312205942385](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312205942385.png)



如下图所示，我们向实现这种结构



![image-20240312212147420](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312212147420.png)

**行 el-row**

![image-20240312212256238](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312212256238.png)

**列 el-col**

> 其实span默认是24份，我们分配每列的空间的话，分配span值即可

![image-20240312212504452](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312212504452.png)

### 1.2.2 页面代码

我们代码要实现下面这种形式

![image-20240312213737310](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312213737310.png)



```html
<template>
  <!--为什么这里写container和app-container？ 因为我们最初的时候导入过样式-->
  <div class="container">
    <!--在此容器上加了边距（上下30px，左右140px）-->
    <div class="app-container">
      组织架构

      <!--展示树形结构-->
      <!--此处正好是标签的属性名叫props，和vue框架中组件传递数据不是一个-->
      <!--default-expand-all属性表示默认将所有的树形结构打开，完整写法是 :default-expand-all=“true” (一定带冒号)-->
      <el-tree :data="depts" :props="defaultProps" default-expand-all>
        <!--v-slot标签只能使用在template标签上-->
        <!--这个data数据其实是el-tree给的，下面的template模板会不断的去循环，有多少个节点就会循环多少次，把每一个数据都塞到了data里面-->
        <template v-slot="{data}">
          <!--节点结构。使用el-tree组件的插槽-->
          <!--会读取这个节点结构并循环渲染到页面上-->
          <!--我们如果把type布局模式设置为"flex"，就可以用厚民安的两个属性，justify="space-between"表示两头对其,align="middle"表示垂直居中-->
          <el-row type="flex" justify="space-between" align="middle" style="width: 100%;height: 40px">
            <!--一行里面有两列,第一列是组织名称，第二列是管理员和操作（下拉菜单）-->
            <el-col>{{ data.name }}</el-col>
            <!--:span="4"一定带着冒号，因为人家想要一个数字类型-->
            <el-col :span="6">
              <span class="tree-manager">{{ data.managerName }}</span>
              <!--下拉菜单组件-->
              <el-dropdown>
                <!--显示区域内容-->
                <span class="el-dropdown-link">
                 操作<i class="el-icon-arrow-down el-icon--right"></i>
             </span>
                <!--下拉菜单的选项-->
                <el-dropdown-menu slot="dropdown">
                  <el-dropdown-item>添加子部门</el-dropdown-item>
                  <el-dropdown-item>编辑部门</el-dropdown-item>
                  <el-dropdown-item>删除</el-dropdown-item>
                </el-dropdown-menu>
              </el-dropdown>
            </el-col>
          </el-row>
        </template>
      </el-tree>
    </div>
  </div>
</template>

<script>
import { getDepartment } from '@/api/department'
import { transListToTreeData } from '@/utils'

export default {
  name: 'Department',
  data() {
    return {
      // 数组属性
      depts: [''],
      defaultProps: {
        // 当前层级数据（在这里找此层级的显示数据）
        label: 'name',
        // 子层级（其实就是层级结构，在这里找子节点）
        children: 'children'
      }
    }
  },
  // 页面初始化的时候会调用这个函数
  created() {
    // 获取部门数据，这个方法是下面methods里面的，不是api里面的
    this.getDepartment()
  },
  methods: {
    async getDepartment() {
      // 下面这个方法是import导入的api请求方法
      const result = await getDepartment()
      // 但是我们获取到的数据是列表的形式，没有层级结构，我们要使用递归的方式完成树形结构
      this.depts = transListToTreeData(result, 0)
    }
  }
}
</script>

<style scoped>
.app-container {
  padding: 30px 140px;
}

.tree-manager {
  width: 50px;
  display: inline-block;
//margin: 10px; margin-right: 50px;
}
</style>

```





### 1.2.3 获取组织架构数据-api

1. **封装获取组织架构的API**

```javascript
// 引入封装的axios工具
import request from '@/utils/request'

/**
 *  获取组织架构数据
 */
export function getDepartment() {
  // request发送登录请求，会得到一个promise结果并将其返回
  return request({
    // 请求地址
    url: '/company/department',
    // 请求方式
    method: 'GET'
    // 请求参数,但是这里没有请求参数
    // data: Data
    // 在ES6中上面data: Data可以简写为 data
  })
}
```

2. **初始化后调用**

```javascript
  // 页面初始化的时候会调用这个函数
  created() {
    // 获取部门数据，这个方法是下面methods里面的，不是api里面的
    this.getDepartment()
  },
  methods: {
    async getDepartment() {
      // 下面这个方法是import导入的api请求方法
      const result = await getDepartment()
      // 但是我们获取到的数据是列表的形式，没有层级结构，我们要使用递归的方式完成树形结构
      this.depts = transListToTreeData(result, 0)
    }
  }
```

3. **赋值数据**

这里我们要使用递归的方式将后端传输过来的列表数据变成树形结构

下图所示的情况

![image-20240312215422002](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312215422002.png)

* **首先分析数据的关联管理**

  层级结构怎么通过数据体现出来的

  如下图所示，其实就是pid与id的关系

  ![image-20240312220407888](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312220407888.png)

```json
{
    "success": true,
    "code": 10000,
    "data": [
        {
            "id": 1,
            "pid": 0,
            "name": "传智教育",
            "code": "CZJY",
            "managerId": 1,
            "managerName": "管理员",
            "introduce": "总部",
            "createTime": "2022-10-26 09:13:37"
        },
        {
            "id": 2,
            "pid": 1,
            "name": "总裁办",
            "code": "ZCB",
            "managerId": 1,
            "managerName": "管理员",
            "introduce": "公司战略部",
            "createTime": "2022-10-26 09:13:37"
        },
        {
            "id": 3,
            "pid": 1,
            "name": "行政部",
            "code": "XZB",
            "managerId": 4,
            "managerName": "黑马文吉星",
            "introduce": "行政部",
            "createTime": "2022-10-26 09:13:39"
        },
        ......................
    ],
    "message": "获取组织架构数据成功"
}
```



* **封装递归函数根据关系转化层级结构**

![image-20240312220558856](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312220558856.png)

```javascript
/**
 * 列表数据转树形数据
 * rootValue: 其实就是pid（父id）
 */
export function transListToTreeData(list, rootValue) {
  const arr = []
  list.forEach(item => {
    if (item.pid === rootValue) {
      // 找到了匹配的节点
      arr.push(item)
      // 当前节点的id和当前节点的字节点的pid相等
      // 下面的方法其实就是找当前节点的子节点
      const children = transListToTreeData(list, item.id) // 找到的节点的子节点
      item.children = children // 将子节点赋值给当前节点
      // 我们先push再赋值childern也没关系，因为是一个对象，地址是一样的
    }
  })
  return arr
}

```



## 1.3 效果图

![image-20240312222227585](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312222227585.png)



# 二、添加子部门

## 2.1 表单弹层

