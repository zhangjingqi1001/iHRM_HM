#  iHRM人力资源 - 组织架构

[TOC]

# 一、展示数据-树形组件

**树形组件：用层级结构展示信息，可展开或者折叠**

![image-20240312202534361](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312202534361.png)

> 使用element-ui组件
>
> https://element.eleme.cn/#/zh-CN/component/tree



## 1.1 组件说明

![image-20240312205537574](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312205537574.png)

```html
<template>
  <!--为什么这里写container和app-container？ 因为我们最初的时候导入过样式-->
  <div class="container">
    <!--在此容器上加了边距（上下30px，左右140px）-->
    <div class="app-container">
      组织架构
      <!--展示树形结构-->
      <!--此处正好是标签的属性名叫props，和vue框架中组件传递数据不是一个-->
      <!--default-expand-all属性表示默认将所有的树形结构打开，完整写法是 :default-expand-all=“true” (一定带冒号)-->
      <el-tree :data="depts" :props="defaultProps" default-expand-all>

      </el-tree>
    </div>
  </div>
</template>

<script>
export default {
  name: 'Department',
  data() {
    return {
      // 数组属性
      depts: [{ name: '传智教育', children: [{ name: '总裁办' }, { name: '行政部' }, { name: '人事部' }] }],
      defaultProps: {
        // 当前层级数据（在这里找此层级的显示数据）
        label: 'name',
        // 子层级（其实就是层级结构，在这里找子节点）
        children: 'children'
      }
    }
  }
}
</script>

<style scoped>
.app-container {
  padding: 30px 140px;
}
</style>

```

**效果图**

![image-20240312205856054](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312205856054.png)

## 1.2 树组件自定义结构获取作用域数据

### 1.2.1 说明

我们其实要实现下面的这种树形结构，在右侧还有操作地方，但是我们在1.1中只展示了名称没有显示右侧

因为element-ui中树形结构默认只显示节点的名称，如果我们想树形结构左边有内容右边也有内容的话，就需要对树形结构进行自定义

我们这个地方需要再使用一个element-ui的行和列组件

![image-20240312205942385](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312205942385.png)



如下图所示，我们向实现这种结构



![image-20240312212147420](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312212147420.png)

**行 el-row**

![image-20240312212256238](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312212256238.png)

**列 el-col**

> 其实span默认是24份，我们分配每列的空间的话，分配span值即可

![image-20240312212504452](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312212504452.png)

### 1.2.2 页面代码

我们代码要实现下面这种形式

![image-20240312213737310](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312213737310.png)



```html
<template>
  <!--为什么这里写container和app-container？ 因为我们最初的时候导入过样式-->
  <div class="container">
    <!--在此容器上加了边距（上下30px，左右140px）-->
    <div class="app-container">
      组织架构

      <!--展示树形结构-->
      <!--此处正好是标签的属性名叫props，和vue框架中组件传递数据不是一个-->
      <!--default-expand-all属性表示默认将所有的树形结构打开，完整写法是 :default-expand-all=“true” (一定带冒号)-->
      <el-tree :data="depts" :props="defaultProps" default-expand-all>
        <!--v-slot标签只能使用在template标签上-->
        <!--这个data数据其实是el-tree给的，下面的template模板会不断的去循环，有多少个节点就会循环多少次，把每一个数据都塞到了data里面-->
        <template v-slot="{data}">
          <!--节点结构。使用el-tree组件的插槽-->
          <!--会读取这个节点结构并循环渲染到页面上-->
          <!--我们如果把type布局模式设置为"flex"，就可以用厚民安的两个属性，justify="space-between"表示两头对其,align="middle"表示垂直居中-->
          <el-row type="flex" justify="space-between" align="middle" style="width: 100%;height: 40px">
            <!--一行里面有两列,第一列是组织名称，第二列是管理员和操作（下拉菜单）-->
            <el-col>{{ data.name }}</el-col>
            <!--:span="4"一定带着冒号，因为人家想要一个数字类型-->
            <el-col :span="6">
              <span class="tree-manager">{{ data.managerName }}</span>
              <!--下拉菜单组件-->
              <el-dropdown>
                <!--显示区域内容-->
                <span class="el-dropdown-link">
                 操作<i class="el-icon-arrow-down el-icon--right"></i>
             </span>
                <!--下拉菜单的选项-->
                <el-dropdown-menu slot="dropdown">
                  <el-dropdown-item>添加子部门</el-dropdown-item>
                  <el-dropdown-item>编辑部门</el-dropdown-item>
                  <el-dropdown-item>删除</el-dropdown-item>
                </el-dropdown-menu>
              </el-dropdown>
            </el-col>
          </el-row>
        </template>
      </el-tree>
    </div>
  </div>
</template>

<script>
import { getDepartment } from '@/api/department'
import { transListToTreeData } from '@/utils'

export default {
  name: 'Department',
  data() {
    return {
      // 数组属性
      depts: [''],
      defaultProps: {
        // 当前层级数据（在这里找此层级的显示数据）
        label: 'name',
        // 子层级（其实就是层级结构，在这里找子节点）
        children: 'children'
      }
    }
  },
  // 页面初始化的时候会调用这个函数
  created() {
    // 获取部门数据，这个方法是下面methods里面的，不是api里面的
    this.getDepartment()
  },
  methods: {
    async getDepartment() {
      // 下面这个方法是import导入的api请求方法
      const result = await getDepartment()
      // 但是我们获取到的数据是列表的形式，没有层级结构，我们要使用递归的方式完成树形结构
      this.depts = transListToTreeData(result, 0)
    }
  }
}
</script>

<style scoped>
.app-container {
  padding: 30px 140px;
}

.tree-manager {
  width: 50px;
  display: inline-block;
//margin: 10px; margin-right: 50px;
}
</style>

```





### 1.2.3 获取组织架构数据-api

1. **封装获取组织架构的API**

```javascript
// 引入封装的axios工具
import request from '@/utils/request'

/**
 *  获取组织架构数据
 */
export function getDepartment() {
  // request发送登录请求，会得到一个promise结果并将其返回
  return request({
    // 请求地址
    url: '/company/department',
    // 请求方式
    method: 'GET'
    // 请求参数,但是这里没有请求参数
    // data: Data
    // 在ES6中上面data: Data可以简写为 data
  })
}
```

2. **初始化后调用**

```javascript
  // 页面初始化的时候会调用这个函数
  created() {
    // 获取部门数据，这个方法是下面methods里面的，不是api里面的
    this.getDepartment()
  },
  methods: {
    async getDepartment() {
      // 下面这个方法是import导入的api请求方法
      const result = await getDepartment()
      // 但是我们获取到的数据是列表的形式，没有层级结构，我们要使用递归的方式完成树形结构
      this.depts = transListToTreeData(result, 0)
    }
  }
```

3. **赋值数据**

这里我们要使用递归的方式将后端传输过来的列表数据变成树形结构

下图所示的情况

![image-20240312215422002](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312215422002.png)

* **首先分析数据的关联管理**

  层级结构怎么通过数据体现出来的

  如下图所示，其实就是pid与id的关系

  ![image-20240312220407888](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312220407888.png)

```json
{
    "success": true,
    "code": 10000,
    "data": [
        {
            "id": 1,
            "pid": 0,
            "name": "传智教育",
            "code": "CZJY",
            "managerId": 1,
            "managerName": "管理员",
            "introduce": "总部",
            "createTime": "2022-10-26 09:13:37"
        },
        {
            "id": 2,
            "pid": 1,
            "name": "总裁办",
            "code": "ZCB",
            "managerId": 1,
            "managerName": "管理员",
            "introduce": "公司战略部",
            "createTime": "2022-10-26 09:13:37"
        },
        {
            "id": 3,
            "pid": 1,
            "name": "行政部",
            "code": "XZB",
            "managerId": 4,
            "managerName": "黑马文吉星",
            "introduce": "行政部",
            "createTime": "2022-10-26 09:13:39"
        },
        ......................
    ],
    "message": "获取组织架构数据成功"
}
```



* **封装递归函数根据关系转化层级结构**

![image-20240312220558856](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312220558856.png)

```javascript
/**
 * 列表数据转树形数据
 * rootValue: 其实就是pid（父id）
 */
export function transListToTreeData(list, rootValue) {
  const arr = []
  list.forEach(item => {
    if (item.pid === rootValue) {
      // 找到了匹配的节点
      arr.push(item)
      // 当前节点的id和当前节点的字节点的pid相等
      // 下面的方法其实就是找当前节点的子节点
      const children = transListToTreeData(list, item.id) // 找到的节点的子节点
      item.children = children // 将子节点赋值给当前节点
      // 我们先push再赋值childern也没关系，因为是一个对象，地址是一样的
    }
  })
  return arr
}

```



## 1.3 效果图

![image-20240312222227585](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240312222227585.png)



## 1.4 修改树形结构bug

当我们点击“操作”的时候，整个树形结构会关闭或者打开，很不方便，然后我们可以将expand-on-click-nod属性设置为false，说明只有点击箭头图标的时候才会展开或者收缩节点

![image-20240317231919450](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240317231919450.png)

```html
<!--展示树形结构-->
<!--此处正好是标签的属性名叫props，和vue框架中组件传递数据不是一个-->
<!--default-expand-all属性表示默认将所有的树形结构打开，完整写法是 :default-expand-all=“true” (一定带冒号)-->
<el-tree :data="depts" :props="defaultProps" default-expand-all :expand-on-click-node="false">
```



# 二、添加子部门

## 2.1 表单弹层

我们可以将“添加”和“修改”功能公用同一个弹层，也就是“添加”和“修改”的时候公用同一个组件

**大体分为两步**：

1. **注册添加子部门事件**
2. **封装弹层组件**
3. **控制弹层显示隐藏**

![image-20240317224454360](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240317224454360.png)

**在如下位置填写**

![image-20240317224945483](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240317224945483.png)



### 2.1.1 下拉菜单点击事件

```html
 <!--下拉菜单组件-->
 <!--@command是下拉菜单的执行方法，当点击下拉菜单中的某一项的时候，就会执行operateDept方法-->
 <el-dropdown @command="operateDept">
   <!--显示区域内容-->
   <span class="el-dropdown-link">
    操作<i class="el-icon-arrow-down el-icon--right"></i>
</span>
   <!--下拉菜单的选项-->
   <el-dropdown-menu slot="dropdown">
     <el-dropdown-item command="add">添加子部门</el-dropdown-item>
     <el-dropdown-item command="edit">编辑部门</el-dropdown-item>
     <el-dropdown-item command="del">删除</el-dropdown-item>
   </el-dropdown-menu>
 </el-dropdown>
```

当点击某一个下拉框的时候，就会将command的值传输到type

```javascript
operateDept(type) {
  alert(type)
}
```

效果为如下所示，这样我们就能根据不同的按钮做出不同的功能了

![image-20240317225504814](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240317225504814.png)



### 2.1.2 封装弹层组件

![image-20240317225913751](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240317225913751.png)





```html
<template>
  <!--:visible用来控制显示和隐藏,由于我们是一个组件，所以我们需要外部传入一个参数来控制显示还是隐藏-->
  <!--@close用于监视关闭弹层（点击右上角×号的时候，就会执行此函数）-->
  <el-dialog title="新增部门" :visible="showDialog" @close="close">
    <!--放置弹层内容-->

  </el-dialog>
</template>

<script>
export default {
  // 接收外部传输过来的值
  props: {
    // 参数showDialog，类型限制为Boolean，默认值为false
    showDialog: { type: Boolean, default: false }
  },
  methods: {
    close() {
      // 修改父组件的值，子传给父亲
      // this.$emit可以触发一个自定义事件（父组件需要接收这个时间），然后把false这个值传出去
      // this.$emit(''，false) 但是我们先不用这个方法
      // 这里我们使用了 sync修饰，表示会接受子组件的事件，也就是update:showDialog这个事件，然后会把值赋值给showDialog
      this.$emit('update:showDialog', false)
    }
  }
}
</script>
```

**在index.vue组件中进行引用**

```html
<template>
  <!--为什么这里写container和app-container？ 因为我们最初的时候导入过样式-->
  <div class="container">
    <!--在此容器上加了边距（上下30px，左右140px）-->
    <div class="app-container">
      组织架构

      <!--展示树形结构-->
      <!--此处正好是标签的属性名叫props，和vue框架中组件传递数据不是一个-->
      <!--default-expand-all属性表示默认将所有的树形结构打开，完整写法是 :default-expand-all=“true” (一定带冒号)-->
      <el-tree :data="depts" :props="defaultProps" default-expand-all :expand-on-click-node="false">
        <!--v-slot标签只能使用在template标签上-->
        <!--这个data数据其实是el-tree给的，下面的template模板会不断的去循环，有多少个节点就会循环多少次，把每一个数据都塞到了data里面-->
        <template v-slot="{data}">
          <!--节点结构。使用el-tree组件的插槽-->
          <!--会读取这个节点结构并循环渲染到页面上-->
          <!--我们如果把type布局模式设置为"flex"，就可以用厚民安的两个属性，justify="space-between"表示两头对其,align="middle"表示垂直居中-->
          <el-row type="flex" justify="space-between" align="middle" style="width: 100%;height: 40px">
            <!--一行里面有两列,第一列是组织名称，第二列是管理员和操作（下拉菜单）-->
            <el-col>{{ data.name }}</el-col>
            <!--:span="4"一定带着冒号，因为人家想要一个数字类型-->
            <el-col :span="6">
              <span class="tree-manager">{{ data.managerName }}</span>
              <!--下拉菜单组件-->
              <!--@command是下拉菜单的执行方法，当点击下拉菜单中的某一项的时候，就会执行operateDept方法-->
              <el-dropdown @command="operateDept" >
                <!--显示区域内容-->
                <span class="el-dropdown-link">
                 操作<i class="el-icon-arrow-down el-icon--right"></i>
             </span>
                <!--下拉菜单的选项-->
                <el-dropdown-menu slot="dropdown">
                  <el-dropdown-item command="add">添加子部门</el-dropdown-item>
                  <el-dropdown-item command="edit">编辑部门</el-dropdown-item>
                  <el-dropdown-item command="del">删除</el-dropdown-item>
                </el-dropdown-menu>
              </el-dropdown>
            </el-col>
          </el-row>
        </template>
      </el-tree>
    </div>
    <!--放置弹层-->
    <!--:show-dialog 是我们在add-dept组件中定义的props-->
    <!--sync修饰，表示会接受子组件的事件，也就是update:showDialog这个事件，然后会把值赋值给下面的showDialog-->
    <add-dept :show-dialog.sync="showDialog"></add-dept>
  </div>
</template>

<script>
import { getDepartment } from '@/api/department'
import { transListToTreeData } from '@/utils'
// 引入封装的弹层组件
import AddDept from './components/add-dept.vue'

export default {
  name: 'Department',
  components: { AddDept },
  // 完成AddDept组件局部注册
  comments: { AddDept },
  data() {
    return {
      // 数组属性
      depts: [''],
      defaultProps: {
        // 当前层级数据（在这里找此层级的显示数据）
        label: 'name',
        // 子层级（其实就是层级结构，在这里找子节点）
        children: 'children'
      },
      // 控制弹层的显示和隐藏
      showDialog: false
    }
  },
  // 页面初始化的时候会调用这个函数
  created() {
    // 获取部门数据，这个方法是下面methods里面的，不是api里面的
    this.getDepartment()
  },
  methods: {
    async getDepartment() {
      // 下面这个方法是import导入的api请求方法
      const result = await getDepartment()
      // 但是我们获取到的数据是列表的形式，没有层级结构，我们要使用递归的方式完成树形结构
      this.depts = transListToTreeData(result, 0)
    },
    operateDept(type) {
      if (type === 'add') {
        // 添加子部门
        // 显示弹层组件
        this.showDialog = true
      }
    }
  }
}
</script>

<style scoped>
.app-container {
  padding: 30px 140px;
}

.tree-manager {
  width: 50px;
  display: inline-block;
//margin: 10px; margin-right: 50px;
}
</style>
```



### 2.1.3  表单结构及校验

![image-20240317232351643](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240317232351643.png)































